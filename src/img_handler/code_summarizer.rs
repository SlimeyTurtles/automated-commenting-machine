use std::default;

use anyhow::{ensure, Context, Result};
use async_openai::types::{
    ChatCompletionRequestMessage, ChatCompletionRequestSystemMessageArgs,
    ChatCompletionRequestUserMessageArgs, ChatCompletionResponseMessage,
    CreateChatCompletionRequestArgs,
};

use inquire::{required, Text};
use regex::Regex;
use reqwest::Client;
use serde::Deserialize;
use tokio::process::Command;
use which::which;
use crate::app_config::config::Config;

/// Stores a single summary message candidate generated by the model
#[derive(Deserialize)]
struct CommitMessageCandidate {
    message: ChatCompletionResponseMessage,
}

/// Stores all the summary message candidates generated by the model
#[derive(Deserialize)]
struct CommitMessageCandidates {
    choices: Vec<CommitMessageCandidate>,
}

/// Asynchronously generates a summary message using the provided HTTP client, configuration, and Git differences.
///
/// Constructs a request payload for the API based on the provided configuration and staged Git differences.
/// Sends the request to the API provider, retrieves and parses the response, and extracts the generated
/// summary message. Post-processes the summary message to keep only the first line and remove leading and trailing backticks.
///
/// # Arguments
///
/// * `http_client` - A reference to the Reqwest HTTP client used to send requests to the API.
/// * `config` - A reference to the configuration containing API details, model information, and prompt contents.
/// * `diff` - A reference to the staged Git differences to be included in the user prompt.
///
/// # Returns
///
/// Returns a `Result` containing the generated summary message as a string on success,
/// or an error if there were issues constructing the request, sending it, or processing the response.
pub async fn generate_slide_summary(
    http_client: &Client,
    config: &Config,
    file_text_list: Vec<String>,
) -> Result<String> {
    
    let mut chat_completion_request_system_message_args_list: Vec<ChatCompletionRequestMessage> = Vec::new();

    chat_completion_request_system_message_args_list.push(
        ChatCompletionRequestSystemMessageArgs::default()
            .content(&config.slides_prompt)
            .build()?
            .into(),
    );

    for file_text in file_text_list {
        chat_completion_request_system_message_args_list.push(
            ChatCompletionRequestUserMessageArgs::default()
                .content(file_text)
                .build()?
                .into(),
        )
    }

    let payload = CreateChatCompletionRequestArgs::default()
        .max_tokens(config.max_chars)
        .model(&config.git_model_name)
        .messages(chat_completion_request_system_message_args_list)
        .build()
        .context("Failed to construct the request payload")?;

    let response = http_client
        .post(format!("{}/chat/completions", &config.git_api_base_url))
        .bearer_auth(&config.api_key)
        .json(&payload)
        .send()
        .await
        .context("Failed to send the request to the API provider")?
        .error_for_status()?
        .json::<CommitMessageCandidates>()
        .await
        .context("Failed to parse the response from the API provider")?;

    let summary_message = response
        .choices
        .first() // Only the first generated summary message is used
        .context("No summary messages generated")?
        .message
        .content
        .as_ref()
        .context("No summary messages generated")?;

    // Post-process the generated summary message to keep only the first line and remove leading and trailing backticks
    let regex_matches = Regex::new(r"(?m)^\s*(?:`\s*(.+?)\s*`|(.+?))\s*$")?
        .captures(summary_message)
        .context("Failed to post-process the generated summary message")?;

    let summary_message = regex_matches
        .get(1)
        .or(regex_matches.get(2))
        .context("Failed to post-process the generated summary message")?
        .as_str()
        .to_string();

    println!("{}", summary_message);

    Ok(summary_message)
}
